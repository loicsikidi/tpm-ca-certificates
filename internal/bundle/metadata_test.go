package bundle

import (
	"testing"

	"github.com/loicsikidi/tpm-ca-certificates/internal/testutil"
)

func TestParseMetadata(t *testing.T) {
	tests := []struct {
		name       string
		bundleData string
		wantDate   string
		wantCommit string
		wantErrMsg string
	}{
		{
			name: "valid bundle with metadata",
			bundleData: `##
## tpm-ca-certificates.pem
##
## Date: 2025-12-04
## Commit: 63e6a017e9c15428b2959cb2760d21f05dea42f4
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
## and contains a list of verified TPM Root Endorsement Certificates.
##

#
# Certificate: Test Certificate
# Owner: TEST
#
-----BEGIN CERTIFICATE-----
MIIBdjCCARygAwIBAgIRAKjIOzWTCC66SJLRB5eewJMwCgYIKoZIzj0EAwIwGTEX
-----END CERTIFICATE-----
`,
			wantDate:   "2025-12-04",
			wantCommit: "63e6a017e9c15428b2959cb2760d21f05dea42f4",
		},
		{
			name: "valid bundle with different date format",
			bundleData: `##
## bundle.pem
##
## Date: 2025-01-03
## Commit: a703c9c414fcad56351b5b6326a7d0cbaf2f0b9c
##
`,
			wantDate:   "2025-01-03",
			wantCommit: "a703c9c414fcad56351b5b6326a7d0cbaf2f0b9c",
		},
		{
			name: "bundle missing date",
			bundleData: `##
## tpm-ca-certificates.pem
##
## Commit: 63e6a017e9c15428b2959cb2760d21f05dea42f4
##
`,
			wantErrMsg: "bundle does not contain required 'Date' metadata in header",
		},
		{
			name: "bundle missing commit",
			bundleData: `##
## tpm-ca-certificates.pem
##
## Date: 2025-12-04
##
`,
			wantErrMsg: "bundle does not contain required 'Commit' metadata in header",
		},
		{
			name: "bundle missing both date and commit",
			bundleData: `##
## tpm-ca-certificates.pem
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
##
`,
			wantErrMsg: "bundle does not contain required 'Date' metadata in header",
		},
		{
			name:       "empty bundle",
			bundleData: ``,
			wantErrMsg: "bundle does not contain required 'Date' metadata in header",
		},
		{
			name: "bundle without header",
			bundleData: `-----BEGIN CERTIFICATE-----
MIIBdjCCARygAwIBAgIRAKjIOzWTCC66SJLRB5eewJMwCgYIKoZIzj0EAwIwGTEX
-----END CERTIFICATE-----
`,
			wantErrMsg: "bundle does not contain required 'Date' metadata in header",
		},
		{
			name: "bundle with extra whitespace in metadata",
			bundleData: `##
## tpm-ca-certificates.pem
##
## Date:   2025-12-04
## Commit:   63e6a017e9c15428b2959cb2760d21f05dea42f4
##
`,
			wantDate:   "2025-12-04",
			wantCommit: "63e6a017e9c15428b2959cb2760d21f05dea42f4",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Parse metadata from bytes
			metadata, err := ParseMetadata([]byte(tt.bundleData))

			// Check error expectations
			if tt.wantErrMsg != "" {
				if err == nil {
					t.Fatalf("Expected error containing %q, got nil", tt.wantErrMsg)
				}
				if !containsString(err.Error(), tt.wantErrMsg) {
					t.Errorf("Expected error containing %q, got %q", tt.wantErrMsg, err.Error())
				}
				return
			}

			// Check success expectations
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if metadata.Date != tt.wantDate {
				t.Errorf("Date mismatch: got %q, want %q", metadata.Date, tt.wantDate)
			}

			if metadata.Commit != tt.wantCommit {
				t.Errorf("Commit mismatch: got %q, want %q", metadata.Commit, tt.wantCommit)
			}
		})
	}
}

func TestParseMetadata_RealBundle(t *testing.T) {
	// Read the embedded test bundle
	data, err := testutil.ReadTestFile(testutil.BundleFile)
	if err != nil {
		t.Fatalf("Failed to read test bundle: %v", err)
	}

	metadata, err := ParseMetadata(data)
	if err != nil {
		t.Fatalf("Failed to parse test bundle: %v", err)
	}

	// Validate that we got something
	if metadata.Date == "" {
		t.Error("Expected non-empty Date from test bundle")
	}

	if metadata.Commit == "" {
		t.Error("Expected non-empty Commit from test bundle")
	}

	// Log the values for visibility
	t.Logf("Parsed test bundle metadata - Date: %s, Commit: %s", metadata.Date, metadata.Commit)
}

// containsString checks if a string contains a substring.
func containsString(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(s) > 0 && len(substr) > 0 && indexString(s, substr) >= 0))
}

// indexString returns the index of substr in s, or -1 if not found.
func indexString(s, substr string) int {
	for i := 0; i+len(substr) <= len(s); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}
