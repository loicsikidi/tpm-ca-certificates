package bundle

import (
	"os"
	"path/filepath"
	"testing"
)

func TestParseMetadata(t *testing.T) {
	tests := []struct {
		name       string
		bundleData string
		wantDate   string
		wantCommit string
		wantErrMsg string
	}{
		{
			name: "valid bundle with metadata",
			bundleData: `##
## tpm-ca-certificates.pem
##
## Date: 2025-12-04
## Commit: 63e6a017e9c15428b2959cb2760d21f05dea42f4
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
## and contains a list of verified TPM Root Endorsement Certificates.
##

#
# Certificate: Test Certificate
# Owner: TEST
#
-----BEGIN CERTIFICATE-----
MIIBdjCCARygAwIBAgIRAKjIOzWTCC66SJLRB5eewJMwCgYIKoZIzj0EAwIwGTEX
-----END CERTIFICATE-----
`,
			wantDate:   "2025-12-04",
			wantCommit: "63e6a017e9c15428b2959cb2760d21f05dea42f4",
		},
		{
			name: "valid bundle with different date format",
			bundleData: `##
## bundle.pem
##
## Date: 2025-01-03
## Commit: a703c9c414fcad56351b5b6326a7d0cbaf2f0b9c
##
`,
			wantDate:   "2025-01-03",
			wantCommit: "a703c9c414fcad56351b5b6326a7d0cbaf2f0b9c",
		},
		{
			name: "bundle missing date",
			bundleData: `##
## tpm-ca-certificates.pem
##
## Commit: 63e6a017e9c15428b2959cb2760d21f05dea42f4
##
`,
			wantErrMsg: "bundle does not contain required 'Date' metadata in header",
		},
		{
			name: "bundle missing commit",
			bundleData: `##
## tpm-ca-certificates.pem
##
## Date: 2025-12-04
##
`,
			wantErrMsg: "bundle does not contain required 'Commit' metadata in header",
		},
		{
			name: "bundle missing both date and commit",
			bundleData: `##
## tpm-ca-certificates.pem
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
##
`,
			wantErrMsg: "bundle does not contain required 'Date' metadata in header",
		},
		{
			name:       "empty bundle",
			bundleData: ``,
			wantErrMsg: "bundle does not contain required 'Date' metadata in header",
		},
		{
			name: "bundle without header",
			bundleData: `-----BEGIN CERTIFICATE-----
MIIBdjCCARygAwIBAgIRAKjIOzWTCC66SJLRB5eewJMwCgYIKoZIzj0EAwIwGTEX
-----END CERTIFICATE-----
`,
			wantErrMsg: "bundle does not contain required 'Date' metadata in header",
		},
		{
			name: "bundle with extra whitespace in metadata",
			bundleData: `##
## tpm-ca-certificates.pem
##
## Date:   2025-12-04
## Commit:   63e6a017e9c15428b2959cb2760d21f05dea42f4
##
`,
			wantDate:   "2025-12-04",
			wantCommit: "63e6a017e9c15428b2959cb2760d21f05dea42f4",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Create temporary file with test data
			tmpFile, err := os.CreateTemp("", "bundle-*.pem")
			if err != nil {
				t.Fatalf("Failed to create temp file: %v", err)
			}
			defer os.Remove(tmpFile.Name())

			if _, err := tmpFile.WriteString(tt.bundleData); err != nil {
				t.Fatalf("Failed to write test data: %v", err)
			}
			tmpFile.Close()

			// Parse metadata
			metadata, err := ParseMetadata(tmpFile.Name())

			// Check error expectations
			if tt.wantErrMsg != "" {
				if err == nil {
					t.Fatalf("Expected error containing %q, got nil", tt.wantErrMsg)
				}
				if !containsString(err.Error(), tt.wantErrMsg) {
					t.Errorf("Expected error containing %q, got %q", tt.wantErrMsg, err.Error())
				}
				return
			}

			// Check success expectations
			if err != nil {
				t.Fatalf("Unexpected error: %v", err)
			}

			if metadata.Date != tt.wantDate {
				t.Errorf("Date mismatch: got %q, want %q", metadata.Date, tt.wantDate)
			}

			if metadata.Commit != tt.wantCommit {
				t.Errorf("Commit mismatch: got %q, want %q", metadata.Commit, tt.wantCommit)
			}
		})
	}
}

func TestParseMetadata_FileNotFound(t *testing.T) {
	_, err := ParseMetadata("/nonexistent/path/bundle.pem")
	if err == nil {
		t.Fatal("Expected error for nonexistent file, got nil")
	}

	if !containsString(err.Error(), "failed to open bundle file") {
		t.Errorf("Expected error about opening file, got: %v", err)
	}
}

func TestParseMetadata_RealBundle(t *testing.T) {
	// Test with the actual tpm-ca-certificates.pem file if it exists
	bundlePath := filepath.Join("..", "..", "tpm-ca-certificates.pem")

	// Check if file exists
	if _, err := os.Stat(bundlePath); os.IsNotExist(err) {
		t.Skip("Skipping test: tpm-ca-certificates.pem not found")
	}

	metadata, err := ParseMetadata(bundlePath)
	if err != nil {
		t.Fatalf("Failed to parse real bundle: %v", err)
	}

	// Validate that we got something
	if metadata.Date == "" {
		t.Error("Expected non-empty Date from real bundle")
	}

	if metadata.Commit == "" {
		t.Error("Expected non-empty Commit from real bundle")
	}

	// Log the values for visibility
	t.Logf("Parsed real bundle metadata - Date: %s, Commit: %s", metadata.Date, metadata.Commit)

	// Expected values based on the file content we saw earlier
	expectedDate := "2025-12-04"
	expectedCommit := "63e6a017e9c15428b2959cb2760d21f05dea42f4"

	if metadata.Date != expectedDate {
		t.Errorf("Date mismatch in real bundle: got %q, want %q", metadata.Date, expectedDate)
	}

	if metadata.Commit != expectedCommit {
		t.Errorf("Commit mismatch in real bundle: got %q, want %q", metadata.Commit, expectedCommit)
	}
}

// containsString checks if a string contains a substring.
func containsString(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(s) > 0 && len(substr) > 0 && indexString(s, substr) >= 0))
}

// indexString returns the index of substr in s, or -1 if not found.
func indexString(s, substr string) int {
	for i := 0; i+len(substr) <= len(s); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}
