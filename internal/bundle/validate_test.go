package bundle_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	bundlepkg "github.com/loicsikidi/tpm-ca-certificates/internal/bundle"
	"github.com/loicsikidi/tpm-ca-certificates/internal/testutil"
)

func TestValidateBundle_ValidBundle(t *testing.T) {
	// Read the valid test bundle
	data, err := testutil.ReadTestFile(testutil.RootBundleFile)
	if err != nil {
		t.Fatalf("failed to read test bundle: %v", err)
	}

	validator := bundlepkg.NewBundleValidator()
	errors, err := validator.ValidateBundle(data)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if len(errors) > 0 {
		t.Errorf("expected no validation errors, got %d:", len(errors))
		for _, e := range errors {
			t.Errorf("  Line %d: %s", e.Line, e.Message)
		}
	}
}

func TestValidateBundle_MissingGlobalMetadata(t *testing.T) {
	bundle := `# Certificate: Test
# Owner: STM
-----BEGIN CERTIFICATE-----
MIIBkTCB+wIJAKHHCgVZU2T9MA0GCSqGSIb3DQEBCwUAMA0xCzAJBgNVBAYTAlVT
-----END CERTIFICATE-----`

	validator := bundlepkg.NewBundleValidator()
	errors, err := validator.ValidateBundle([]byte(bundle))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if len(errors) == 0 {
		t.Fatal("expected validation errors for missing global metadata")
	}

	// Should error on line 1 for missing ## marker
	found := false
	for _, e := range errors {
		if strings.Contains(e.Message, "global metadata block marker") {
			found = true
			break
		}
	}
	if !found {
		t.Error("expected error about missing global metadata block marker")
	}
}

func TestValidateBundle_InvalidDateFormat(t *testing.T) {
	bundle := `##
## tpm-ca-certificates.pem
##
## Date: 2024/12/08
## Commit: 1234567890abcdef1234567890abcdef12345678
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
## and contains a list of verified TPM Root Endorsement Certificates.
##
`

	validator := bundlepkg.NewBundleValidator()
	errors, err := validator.ValidateBundle([]byte(bundle))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if len(errors) == 0 {
		t.Fatal("expected validation errors for invalid date format")
	}

	found := false
	for _, e := range errors {
		if strings.Contains(e.Message, "invalid date format") {
			found = true
			break
		}
	}
	if !found {
		t.Error("expected error about invalid date format")
	}
}

func TestValidateBundle_InvalidCommitHash(t *testing.T) {
	tests := []struct {
		name   string
		commit string
	}{
		{"too short", "abc123"},
		{"uppercase", "1234567890ABCDEF1234567890ABCDEF12345678"},
		{"invalid chars", "1234567890abcdef1234567890abcdef1234567g"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			bundle := `##
## tpm-ca-certificates.pem
##
## Date: 2024-12-08
## Commit: ` + tt.commit + `
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
## and contains a list of verified TPM Root Endorsement Certificates.
##
`

			validator := bundlepkg.NewBundleValidator()
			errors, err := validator.ValidateBundle([]byte(bundle))
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if len(errors) == 0 {
				t.Fatal("expected validation errors for invalid commit hash")
			}

			found := false
			for _, e := range errors {
				if strings.Contains(e.Message, "invalid commit hash") {
					found = true
					break
				}
			}
			if !found {
				t.Error("expected error about invalid commit hash")
			}
		})
	}
}

func TestValidateBundle_MissingRequiredFields(t *testing.T) {
	bundle := `##
## tpm-ca-certificates.pem
##
## Date: 2024-12-08
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
## and contains a list of verified TPM Root Endorsement Certificates.
##
`

	validator := bundlepkg.NewBundleValidator()
	errors, err := validator.ValidateBundle([]byte(bundle))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if len(errors) == 0 {
		t.Fatal("expected validation errors for missing commit")
	}

	found := false
	for _, e := range errors {
		if strings.Contains(e.Message, "missing required 'Commit' field") {
			found = true
			break
		}
	}
	if !found {
		t.Error("expected error about missing Commit field")
	}
}

func TestValidateBundle_InvalidVendorID(t *testing.T) {
	bundle := `##
## tpm-ca-certificates.pem
##
## Date: 2024-12-08
## Commit: 1234567890abcdef1234567890abcdef12345678
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
## and contains a list of verified TPM Root Endorsement Certificates.
##

#
# Certificate: Test Certificate
# Owner: INVALID
#
# Issuer: CN=Test
# Serial Number: 1 (0x1)
# Subject: CN=Test
# Not Valid Before: Mon Jan 01 00:00:00 2024
# Not Valid After: Mon Jan 01 00:00:00 2025
# Fingerprint (SHA-256): AA:BB:CC:DD:EE:FF:00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33:44:55:66:77:88:99
# Fingerprint (SHA1): AA:BB:CC:DD:EE:FF:00:11:22:33:44:55:66:77:88:99
-----BEGIN CERTIFICATE-----
MIIBkTCB+wIJAKHHCgVZU2T9MA0GCSqGSIb3DQEBCwUAMA0xCzAJBgNVBAYTAlVT
-----END CERTIFICATE-----`

	validator := bundlepkg.NewBundleValidator()
	errors, err := validator.ValidateBundle([]byte(bundle))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if len(errors) == 0 {
		t.Fatal("expected validation errors for invalid vendor ID")
	}

	found := false
	for _, e := range errors {
		if strings.Contains(e.Message, "invalid vendor ID") {
			found = true
			break
		}
	}
	if !found {
		t.Error("expected error about invalid vendor ID")
	}
}

func TestValidateBundle_InvalidFingerprintFormat(t *testing.T) {
	tests := []struct {
		name        string
		fingerprint string
		hashType    string
	}{
		{"lowercase sha256", "aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99:aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99", "SHA-256"},
		{"no colons sha256", "AABBCCDDEEFF00112233445566778899AABBCCDDEEFF00112233445566778899", "SHA-256"},
		{"wrong length sha256", "AA:BB:CC:DD", "SHA-256"},
		{"lowercase sha1", "aa:bb:cc:dd:ee:ff:00:11:22:33:44:55:66:77:88:99", "SHA1"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			fpField := "Fingerprint (SHA-256)"
			if tt.hashType == "SHA1" {
				fpField = "Fingerprint (SHA1)"
			}

			bundle := `##
## tpm-ca-certificates.pem
##
## Date: 2024-12-08
## Commit: 1234567890abcdef1234567890abcdef12345678
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
## and contains a list of verified TPM Root Endorsement Certificates.
##

#
# Certificate: Test Certificate
# Owner: STM
#
# Issuer: CN=Test
# Serial Number: 1 (0x1)
# Subject: CN=Test
# Not Valid Before: Mon Jan 01 00:00:00 2024
# Not Valid After: Mon Jan 01 00:00:00 2025
# ` + fpField + `: ` + tt.fingerprint + `
# Fingerprint (SHA1): AA:BB:CC:DD:EE:FF:00:11:22:33:44:55:66:77:88:99
-----BEGIN CERTIFICATE-----
MIIBkTCB+wIJAKHHCgVZU2T9MA0GCSqGSIb3DQEBCwUAMA0xCzAJBgNVBAYTAlVT
-----END CERTIFICATE-----`

			if tt.hashType == "SHA1" {
				// Need valid SHA256 first
				bundle = strings.Replace(bundle, "# Fingerprint (SHA1): AA:BB:CC:DD:EE:FF:00:11:22:33:44:55:66:77:88:99",
					"# Fingerprint (SHA-256): AA:BB:CC:DD:EE:FF:00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33:44:55:66:77:88:99\n# Fingerprint (SHA1): "+tt.fingerprint, 1)
			}

			validator := bundlepkg.NewBundleValidator()
			errors, err := validator.ValidateBundle([]byte(bundle))
			if err != nil {
				t.Fatalf("unexpected error: %v", err)
			}

			if len(errors) == 0 {
				t.Fatal("expected validation errors for invalid fingerprint format")
			}

			found := false
			for _, e := range errors {
				if strings.Contains(e.Message, "invalid "+tt.hashType+" fingerprint") {
					found = true
					break
				}
			}
			if !found {
				t.Errorf("expected error about invalid %s fingerprint", tt.hashType)
			}
		})
	}
}

func TestValidateBundle_MissingCertificateMetadata(t *testing.T) {
	bundle := `##
## tpm-ca-certificates.pem
##
## Date: 2024-12-08
## Commit: 1234567890abcdef1234567890abcdef12345678
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
## and contains a list of verified TPM Root Endorsement Certificates.
##

#
# Certificate: Test Certificate
# Owner: STM
#
-----BEGIN CERTIFICATE-----
MIIBkTCB+wIJAKHHCgVZU2T9MA0GCSqGSIb3DQEBCwUAMA0xCzAJBgNVBAYTAlVT
-----END CERTIFICATE-----`

	validator := bundlepkg.NewBundleValidator()
	errors, err := validator.ValidateBundle([]byte(bundle))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if len(errors) == 0 {
		t.Fatal("expected validation errors for missing certificate metadata")
	}

	// Should have multiple errors for missing required fields
	requiredFields := []string{"Issuer", "Serial Number", "Subject", "Not Valid Before", "Not Valid After", "Fingerprint (SHA-256)", "Fingerprint (SHA1)"}
	for _, field := range requiredFields {
		found := false
		for _, e := range errors {
			if strings.Contains(e.Message, "missing required '"+field+"' field") {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("expected error about missing %s field", field)
		}
	}
}

func TestValidateBundleFile(t *testing.T) {
	// Create temporary directory
	tmpDir := t.TempDir()

	// Test valid bundle
	validData, err := testutil.ReadTestFile(testutil.RootBundleFile)
	if err != nil {
		t.Fatalf("failed to read test bundle: %v", err)
	}

	validPath := filepath.Join(tmpDir, "valid.pem")
	if err := os.WriteFile(validPath, validData, 0644); err != nil {
		t.Fatalf("failed to write valid bundle: %v", err)
	}

	validator := bundlepkg.NewBundleValidator()

	// Read and validate
	data, err := os.ReadFile(validPath)
	if err != nil {
		t.Fatalf("failed to read bundle: %v", err)
	}

	errors, err := validator.ValidateBundle(data)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	if len(errors) > 0 {
		t.Errorf("expected no validation errors for valid bundle, got %d:", len(errors))
		for _, e := range errors {
			t.Errorf("  Line %d: %s", e.Line, e.Message)
		}
	}
}

func TestValidateBundle_MaxErrors(t *testing.T) {
	// Create a bundle with many errors
	bundle := `##
## tpm-ca-certificates.pem
##
## Date: invalid-date
## Commit: invalid
##
## This file has been auto-generated by tpmtb (TPM Trust Bundle)
## and contains a list of verified TPM Root Endorsement Certificates.
##
`
	// Add multiple certificates with errors
	for i := 0; i < 15; i++ {
		bundle += `
#
# Certificate: Test ` + string(rune('A'+i)) + `
# Owner: INVALID
#
-----BEGIN CERTIFICATE-----
INVALID
-----END CERTIFICATE-----
`
	}

	validator := bundlepkg.NewBundleValidator()
	errors, err := validator.ValidateBundle([]byte(bundle))
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}

	// Should cap at maxErrors (10)
	if len(errors) != 10 {
		t.Errorf("expected exactly 10 errors (max), got %d", len(errors))
	}
}

func TestValidateDate(t *testing.T) {
	tests := []struct {
		name        string
		date        string
		expectError bool
	}{
		{
			name:        "valid date",
			date:        "2024-06-15",
			expectError: false,
		},
		{
			name:        "valid date with leading zeros",
			date:        "2024-01-01",
			expectError: false,
		},
		{
			name:        "invalid format - missing day",
			date:        "2024-06",
			expectError: true,
		},
		{
			name:        "invalid format - wrong separator",
			date:        "2024/06/15",
			expectError: true,
		},
		{
			name:        "invalid format - not a date",
			date:        "not-a-date",
			expectError: true,
		},
		{
			name:        "invalid format - incomplete",
			date:        "2024-06-1",
			expectError: true,
		},
		{
			name:        "empty date",
			date:        "",
			expectError: true,
		},
		{
			name:        "invalid date - month 13",
			date:        "2024-13-01",
			expectError: true,
		},
		{
			name:        "invalid date - day 32",
			date:        "2024-01-32",
			expectError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := bundlepkg.ValidateDate(tt.date)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}
		})
	}
}

func TestValidateCommit(t *testing.T) {
	tests := []struct {
		name        string
		commit      string
		expectError bool
	}{
		{
			name:        "valid commit hash",
			commit:      "a1b2c3d4e5f67890123456789abcdef012345678",
			expectError: false,
		},
		{
			name:        "valid commit hash - all lowercase",
			commit:      "fedcba9876543210fedcba9876543210fedcba98",
			expectError: false,
		},
		{
			name:        "invalid - uppercase letters",
			commit:      "A1B2C3D4E5F67890123456789ABCDEF012345678",
			expectError: true,
		},
		{
			name:        "invalid - too short",
			commit:      "a1b2c3d4e5f67890123456789abcdef0123456",
			expectError: true,
		},
		{
			name:        "invalid - too long",
			commit:      "a1b2c3d4e5f67890123456789abcdef0123456789",
			expectError: true,
		},
		{
			name:        "invalid - contains non-hex characters",
			commit:      "g1b2c3d4e5f67890123456789abcdef012345678",
			expectError: true,
		},
		{
			name:        "empty commit",
			commit:      "",
			expectError: true,
		},
		{
			name:        "invalid - special characters",
			commit:      "a1b2c3d4-5f67-890-23456789abcdef012345678",
			expectError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := bundlepkg.ValidateCommit(tt.commit)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}
		})
	}
}
