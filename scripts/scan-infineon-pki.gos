#!/usr/bin/env -S gos run

package main

import (
	"flag"
	"fmt"
	"net/http"
	"os"
	"sort"
	"sync"
)

const (
	rsaURLTemplate = "https://pki.infineon.com/OptigaRsaMfrCA%03d/OptigaRsaMfrCA%03d.crt"
	eccURLTemplate = "https://pki.infineon.com/OptigaEccMfrCA%03d/OptigaEccMfrCA%03d.crt"
	defaultCount   = 150
)

func main() {
	count := flag.Int("count", defaultCount, "maximum number to check")
	out := flag.String("out", "", "output file (default: stdout)")
	flag.Parse()

	var (
		wg    sync.WaitGroup
		mu    sync.Mutex
		urls  []string
	)

	// Channel to limit concurrent requests
	semaphore := make(chan struct{}, 10)

	for i := 0; i < *count; i++ {
		wg.Add(2) // RSA and ECC

		// Check RSA URL
		go func(num int) {
			defer wg.Done()
			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			url := fmt.Sprintf(rsaURLTemplate, num, num)
			if checkURL(url) {
				mu.Lock()
				urls = append(urls, url)
				mu.Unlock()
			}
		}(i)

		// Check ECC URL
		go func(num int) {
			defer wg.Done()
			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			url := fmt.Sprintf(eccURLTemplate, num, num)
			if checkURL(url) {
				mu.Lock()
				urls = append(urls, url)
				mu.Unlock()
			}
		}(i)
	}

	wg.Wait()

	// Sort URLs alphabetically
	sort.Strings(urls)

	if len(urls) == 0 {
		fmt.Fprintln(os.Stderr, "No certificates found")
		os.Exit(1)
	}

	// Determine output destination
	var output *os.File
	if *out == "" {
		output = os.Stdout
	} else {
		f, err := os.Create(*out)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to create output file: %v\n", err)
			os.Exit(1)
		}
		defer f.Close()
		output = f
	}

	// Print all found URLs
	for _, url := range urls {
		fmt.Fprintln(output, url)
	}
}

// checkURL verifies if a URL returns HTTP 200
func checkURL(url string) bool {
	resp, err := http.Head(url)
	if err != nil {
		return false
	}
	defer resp.Body.Close()

	return resp.StatusCode == http.StatusOK
}
