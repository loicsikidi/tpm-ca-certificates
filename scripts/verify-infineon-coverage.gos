#!/usr/bin/env -S gos run
// /// script
// dependencies = [
//     "go.yaml.in/yaml/v4@v4.0.0-rc.3",
// ]
// ///

package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"sort"
	"strings"

	"go.yaml.in/yaml/v4"
)

type Config struct {
	Version string   `yaml:"version"`
	Vendors []Vendor `yaml:"vendors"`
}

type Vendor struct {
	ID           string        `yaml:"id"`
	Name         string        `yaml:"name"`
	Certificates []Certificate `yaml:"certificates"`
}

type Certificate struct {
	Name       string     `yaml:"name"`
	URL        string     `yaml:"url"`
	Validation Validation `yaml:"validation"`
}

type Validation struct {
	Fingerprint Fingerprint `yaml:"fingerprint"`
}

type Fingerprint struct {
	SHA1   string `yaml:"sha1,omitempty"`
	SHA256 string `yaml:"sha256,omitempty"`
}

func main() {
	urlsFile := flag.String("urls", "", "path to file containing available URLs (generated by scan-infineon-pki.go)")
	configFile := flag.String("config", ".tpm-intermediates.yaml", "path to config file")
	vendorID := flag.String("vendor-id", "IFX", "vendor ID to check")
	flag.Parse()

	if *urlsFile == "" {
		fmt.Fprintln(os.Stderr, "Error: --urls flag is required")
		fmt.Fprintln(os.Stderr, "Usage: verify-infineon-coverage.go --urls <file> [--config <file>] [--vendor-id <id>]")
		os.Exit(1)
	}

	// Load available URLs from file
	availableURLs, err := loadURLsFromFile(*urlsFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading URLs: %v\n", err)
		os.Exit(1)
	}
	fmt.Fprintf(os.Stderr, "Found %d available certificates in %s\n", len(availableURLs), *urlsFile)

	// Load config file
	configURLs, err := loadConfigURLs(*configFile, *vendorID)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
		os.Exit(1)
	}
	fmt.Fprintf(os.Stderr, "Found %d certificates in config\n", len(configURLs))

	// Find missing URLs
	missingURLs := findMissing(availableURLs, configURLs)

	if len(missingURLs) == 0 {
		fmt.Println("✅ All available Infineon certificates are present in the config file")
		return
	}

	fmt.Printf("❌ Found %d missing certificates:\n\n", len(missingURLs))
	for _, url := range missingURLs {
		fmt.Println(url)
	}
	os.Exit(1)
}

// loadURLsFromFile reads URLs from a file (one per line)
func loadURLsFromFile(filename string) ([]string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	var urls []string
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line != "" && !strings.HasPrefix(line, "#") {
			urls = append(urls, line)
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	sort.Strings(urls)
	return urls, nil
}

// loadConfigURLs loads URLs from the config file for a specific vendor
func loadConfigURLs(configFile, vendorID string) ([]string, error) {
	data, err := os.ReadFile(configFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse YAML: %w", err)
	}

	// Find the vendor
	for _, vendor := range config.Vendors {
		if vendor.ID == vendorID {
			urls := make([]string, 0, len(vendor.Certificates))
			for _, cert := range vendor.Certificates {
				urls = append(urls, cert.URL)
			}
			sort.Strings(urls)
			return urls, nil
		}
	}

	return nil, fmt.Errorf("vendor with ID '%s' not found in config", vendorID)
}

// findMissing returns URLs that are in available but not in config
func findMissing(available, config []string) []string {
	configSet := make(map[string]bool, len(config))
	for _, url := range config {
		configSet[url] = true
	}

	var missing []string
	for _, url := range available {
		if !configSet[url] {
			missing = append(missing, url)
		}
	}

	return missing
}
